% --- Weighted operator matrix element sampling function ---

function [CfgP, RWOpCells, CfgIndsP] = RWMatEls(OperatorObj,AnsatzObj,Cfg,InitCells,CfgInds,Ind)
% This function takes some input configurations and associated values (such
% as operator local values) and outputs the set of configurations linked by
% the input Operator as well as operator local values weighted by PsiRatio.
% Each CfgP has an associated RWOpCells cell array containing accrued
% operator local values which are multiplied later.

% For a non-diagonal two site operator, if there is a summation over one of
% the indices this is labelled using CfgInds for use in the final
% summation. If no index is specified, it is assumed the total sum is over
% all configurations generated by this operator and no such labelling is
% required.

% As this operator is a two-site operator, need a vector Ind input.
% Any Ind set to zero suggests final sum over the zero index.
% If Ind(1) == Ind(2), assume final sum over sites but leave separation as
% free index. If Ind(3) is present, assume that this operator gives a
% vector output for a single Diff, and Ind(3) indicates the dimension in
% which this vector should be.

HilbertObj = OperatorObj.Hilbert; GraphObj = OperatorObj.Graph;

% Initialise storage for new Cfgs and operator values.
CfgCells = cell(numel(Cfg),1); TempCells = cell(numel(Cfg),1);

% Conversion of IndCells for easier manipulation and recombination.
IndCells = mat2cell(CfgInds,ones(numel(Cfg),1));
% Each entry will initially be a (1xM) vector where M is the order of the
% final combined operator output.

DCount = zeros(numel(Cfg),1);
for c = 1:numel(Cfg)
    AnsatzObjC = PrepPsi(AnsatzObj,Cfg(c));
    % Need some checks to trim unnecessary work.
    if sum(Ind) ~= 0
        if Ind(1) == Ind(2) && IndCells{c}(Ind(1)) ~= 0
            % In this case, existing Cfgs already labelled with (assumed)
            % separation index - reduce BondMap to same as Cfg index to
            % avoid overworking for no point.
            BondMap = {GraphObj.BondMap{IndCells{c}(Ind(1))}};
        else
            % No free indices in this case, and all configurations generated
            % here are eventually summed together. Whether this is a global sum
            % over all possible separations or only over the principal bonds
            % depends on the initialising Graph.
            BondMap = GraphObj.BondMap;
        end
    else
        BondMap = {GraphObj.Bonds};
    end
    
    GraphCells = cell(numel(BondMap),3); DCountG = zeros(numel(BondMap),1);
    for b = 1:numel(BondMap) % For each separation, generate elements.
        TempGraph.Bonds = BondMap{b}; TempGraph.SLInds = GraphObj.SLInds;
        TempOp = OperatorObj; TempOp.Graph = TempGraph;
        [Diff,OpMatEls] = TempOp.CorrMatEls(Cfg(c));
        % Individual OpMatEls are scalar.
        Diff = reshape(Diff,numel(Diff),1); DiffInds = zeros(numel(Diff),numel(IndCells{c}));
        % Diff should be trimmed to relevant allowed configurations.
        FFlag = 0; % Flag that if triggered will result in trimming.
        for d = 1:numel(Diff)
            % Following covers two cases:
            % 1. No free indices - keep all configurations and later
            % sum over them. No alteration to existing indices.
            % 2. Free index is separation - BondMap trimming suffices,
            % any Diffs that make it here are fine.
            if (Ind(1) - Ind(2)) == 0
                if (Ind(1) ~= 0) && (IndCells{c}(Ind(1)) == 0)
                    DiffInds(d,:) = IndCells{c}; DiffInds(d,Ind(1)) = b;
                else
                    DiffInds(d,:) = IndCells{c};
                end
                FFlag = 0;
            else
                % Following covers cases where first index is free.
                for s = 1:2
                    if Ind(s) ~= 0
                        if IndCells{c}(Ind(s)) ~= 0
                            % Pre-existing terms with first index - keep
                            % Diff.pos(1) == IndCells{c}(Ind(1)).
                            if Diff.pos(s) ~= IndCells{c}(Ind(s))
                                FFlag = 1;
                            else
                                DiffInds(d,:) = IndCells{c}; % Summing indices unaltered.
                            end
                        else
                            DiffInds(d,:) = IndCells{c};
                            DiffInds(d,Ind(s)) = Diff.pos(s); % Add current index.
                        end
                    end
                end
            end
            
            if FFlag == 0
                % Weight each matrix element by the associated PsiRatio.
                PsiRatio = AnsatzObjC.PsiRatio(Diff(d));
                if isnan(PsiRatio) || isinf(PsiRatio)
                    PsiRatio = 0;
                end
                OpMatEls(d,:) = OpMatEls(d,:) * PsiRatio;
            else % Forbidden Diffs are trimmed, marked by OpMatEls(d) = 0.
                OpMatEls(d,:) = 0*OpMatEls(d,:); FFlag = 0; % Restore FFlag for subsequent use.
            end
        end
        
        % Trim any zero values.
        Diff = Diff(OpMatEls(:,1)~=0); OpMatEls = OpMatEls(OpMatEls(:,1)~=0,:);
        DiffInds = DiffInds(OpMatEls(:,1)~=0,:);
        DCountG(b) = numel(Diff);
        % Reshape OpMatEls if a third Ind is specified (used for vector
        % outputs).
        if (numel(Ind) == 3) && (numel(OpMatEls) ~= 0)% If a third Ind is included, assume Ind(3) is specified.
            OpMatEls = reshape(OpMatEls,[numel(Diff) ones(1,Ind(3)-2) numel(OpMatEls(1,:))]);
        end
        GraphCells{b,1} = Diff; GraphCells{b,2} = OpMatEls; GraphCells{b,3} = DiffInds;
    end
    % Unpackage Diffs, OpMatEls and Inds from GraphCells.
    Diff(sum(DCountG)) = GraphCells{1}(1);
    for b = 1:numel(BondMap)
        DInds = (1:DCountG(b)) + sum(DCountG(1:(b-1)));
        Diff(DInds) = GraphCells{b,1};
    end
    OpMatEls = cell2mat(GraphCells(:,2));
    Inds = cell2mat(GraphCells(:,3));
    % Convert Diffs to Cfgs and store in CfgCells.
    CfgCells{c} = HilbertObj.Diff2Cfg(Diff,Cfg(c));
    % Store weighted matrix elements in TempCells for later
    % unpacking.
    TempCells{c} = OpMatEls;
    % Store (potentially altered) summing indices in IndCells.
    IndCells{c} = Inds;
    DCount(c) = numel(Diff);
end
% CfgInds tracks any particular sum order for any new configurations
% generated. Can regenerate the list from IndCells.
CfgIndsP = cell2mat(IndCells);

% Unpack all the generated configurations from CfgCells.
CfgP(sum(DCount)) = CfgCells{1}(1);
for c = 1:numel(Cfg)
    CfgP((1:DCount(c))+sum(DCount(1:(c-1)))) = CfgCells{c};
end

% Create storage for collection of accrued operator values.
RWOpCells = cell(numel(CfgP),size(InitCells,2)+1); rcount = 1;
for c = 1:numel(Cfg) % Loop over supplied configurations.
    for d = 1:size(TempCells{c},1) % Loop over generated configurations.
        CfgVal = TempCells{c}(d,:);
        if numel(Ind) == 3 % If a third Ind is included, assume Ind(3) is specified.
            CfgVal = reshape(CfgVal,[ones(1,Ind(3)-1) numel(CfgVal)]);
        end
        if isempty(InitCells)
            RWOpCells(rcount,:) = {CfgVal};
        else
            RWOpCells(rcount,:) = {InitCells{c,:}, CfgVal}; % Append new matrix elements to cell array.
        end
        rcount = rcount + 1;
    end
end

end